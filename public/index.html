<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Labor1</title>
    <link rel="stylesheet" href="./style/style.css" />
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@1.0.2/dist/tfjs-vis.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  </head>
  <body>
    <div class="app">
      <div class="canvas-draw-wrap">
        <div class="show-block">
          <canvas id="canvas_draw" width="200" height="200"></canvas>
          <img class="view-img hide-display" id="view_img" />
        </div>
      </div>
      <div class="btns">
        <button id="btn-predict">Старт</button>
        <div class="input-img-wrp">
          <label class="input-label-img" id="labelImg" for="input_img"> Загрузить </label>
          <input class="input-img" id="input_img" type="file" accept=".jpg, .jpeg, .png" />
        </div>
        <button id="btn-clear">Удалить</button>
      </div>
      <div class="prediction-txt-wrp">
        <p id="prediction-txt"></p>
      </div>
    </div>

    <script>
      var model

      var canvasStrokeStyle = 'white'
      var canvasLineJoin = 'round'
      var canvasLineWidth = 10

      var clickX = new Array()
      var clickY = new Array()
      var clickD = new Array()
      var drawing

      var clearBtn = document.getElementById('btn-clear')
      var predictBtn = document.getElementById('btn-predict')
      var text = document.getElementById('prediction-txt')

      var canvas = document.getElementById('canvas_draw')
      var viewImg = document.getElementById('view_img')
      var inputImg = document.getElementById('input_img')

      if (typeof G_vmlCanvasManager != 'undefined') {
        canvas = G_vmlCanvasManager.initElement(canvas)
      }

      var ctx = canvas.getContext('2d')

      canvas.onmousedown = function (e) {
        var rect = canvas.getBoundingClientRect()
        var mouseX = e.clientX - rect.left
        var mouseY = e.clientY - rect.top
        drawing = true
        addUserGesture(mouseX, mouseY)
        drawOnCanvas()
      }

      canvas.onmousemove = function (e) {
        if (drawing) {
          var rect = canvas.getBoundingClientRect()
          var mouseX = e.clientX - rect.left
          var mouseY = e.clientY - rect.top
          addUserGesture(mouseX, mouseY, true)
          drawOnCanvas()
        }
      }

      canvas.onmouseup = function (e) {
        drawing = false
      }

      canvas.mouseleave = function (e) {
        drawing = false
      }

      function addUserGesture(x, y, dragging) {
        clickX.push(x)
        clickY.push(y)
        clickD.push(dragging)
      }

      function drawOnCanvas() {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)

        ctx.strokeStyle = canvasStrokeStyle
        ctx.lineJoin = canvasLineJoin
        ctx.lineWidth = canvasLineWidth

        for (var i = 0; i < clickX.length; i++) {
          ctx.beginPath()
          if (clickD[i] && i) {
            ctx.moveTo(clickX[i - 1], clickY[i - 1])
          } else {
            ctx.moveTo(clickX[i] - 1, clickY[i])
          }
          ctx.lineTo(clickX[i], clickY[i])
          ctx.closePath()
          ctx.stroke()
        }
      }

      clearBtn.onclick = function () {
        ctx.restore()
        ctx.setTransform(1, 0, 0, 1, 0, 0)
        ctx.scale(1, 1)
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        clickX = new Array()
        clickY = new Array()
        clickD = new Array()
        text.innerHTML = ''
        setShow(true, false)
      }

      async function loadModel() {
        model = await tf.loadLayersModel('./models/model.json')
      }

      loadModel()

      function preprocessCanvas(image) {
        var tensor = tf.browser
          .fromPixels(image)
          .resizeNearestNeighbor([28, 28])
          .mean(2)
          .expandDims(2)
          .expandDims()
          .toFloat()
        return tensor.div(255.0)
      }

      predictBtn.onclick = async function () {
        var tensor
        if (!canvas.classList.contains('hide-display')) {
          tensor = preprocessCanvas(canvas)
        } else if (!viewImg.classList.contains('hide-display')) {
          tensor = preprocessCanvas(viewImg)
        }
        var predictions = await model.predict(tensor).data()
        var results = Array.from(predictions)

        displayLabel(results)
      }

      function displayLabel(data) {
        var max = data[0]
        var maxIndex = 0

        for (var i = 1; i < data.length; i++) {
          if (data[i] > max) {
            maxIndex = i
            max = data[i]
          }
        }
        text.innerHTML =
          'Нарисованная цифра: <b>' + maxIndex + '</b>, процент совпадения <b>' + Math.trunc(max * 100) + '%</b>'
      }

      function setShow(isCanvas, isImage) {
        if (isCanvas) {
          canvas.classList.remove('hide-display')
          viewImg.classList.add('hide-display')
        } else if (isImage) {
          canvas.classList.add('hide-display')
          viewImg.classList.remove('hide-display')
        }
      }

      function clearUrl() {
        inputImg.value = ''
        viewImg.removeAttribute('src')
      }

      function readUrl() {
        if (inputImg.files && inputImg.files[0]) {
          var reader = new FileReader()
          reader.onload = e => {
            viewImg.setAttribute('src', e.target.result)
          }
          reader.readAsDataURL(inputImg.files[0])
        }
        setShow(false, true)
        clearUrl()
      }

      inputImg.onchange = readUrl
    </script>
  </body>
</html>
